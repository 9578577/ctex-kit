-- 
--  This is file `xpinyin.lua',
--  generated with the docstrip utility.
-- 
--  The original source files were:
-- 
--  xpinyin.dtx  (with options: `lua')
--  
--     Copyright (C) 2012-2014 by Qing Lee <sobenlee@gmail.com>
--  --------------------------------------------------------------------------
--     This work may be distributed and/or modified under the
--     conditions of the LaTeX Project Public License, either version 1.3
--     of this license or (at your option) any later version.
--     The latest version of this license is in
--       http://www.latex-project.org/lppl.txt
--     and version 1.3 or later is part of all distributions of LaTeX
--     version 2005/12/01 or later.
--  
--     This work has the LPPL maintenance status "maintained".
--     The Current Maintainer of this work is Qing Lee.
--  
xpinyin       = xpinyin or { }
local xpinyin = xpinyin
xpinyin.tzoffset = "+0000"
do
  -- Compute the difference in seconds between local time and UTC.
  local function get_timezone()
    local now = os.time()
    return os.difftime(now, os.time(os.date("!*t", now)))
  end
  -- Return a timezone string in ISO 8601:2000 standard form (+hhmm or -hhmm)
  local function get_tzoffset(timezone)
    local h, m = math.modf(timezone / 3600)
    return string.format("%+.4d", 100 * h + 60 * m)
  end
  xpinyin.tzoffset = get_tzoffset(get_timezone())
end
xpinyin = {
  svnid    = "$Id$",
  uchar    = unicode.utf8.char,
  readings = { },
  fixreadings = {
    {"U+3007", "Mandarin", "lÃ­ng"}
  },
  database = {
    source  = "http://www.unicode.org/Public/UNIDATA/Unihan.zip",
    file    = "Unihan_Readings.txt",
    date    = "Date: 2014-05-09 18:17:02 GMT [JHJ]",
    version = "Unicode version: 7.0.0",
    dbfile  = "xpinyin.db"
  },
  preamble = string.gsub([[
    %%
    %%  Do not edit this file!
    %%  Created from Unihan database:
    %%
    %%    $file
    %%    $date
    %%    $version
    %%
    %%  by "texlua xpinyin.lua" on ]]
               .. os.date("%Y-%m-%d %X ") .. xpinyin.tzoffset
               .. "\n%%", "[ ]+(%%%%)", "%1")
}
function xpinyin.maketable (txt)
  local f = io.open(txt or xpinyin.database.file, "r")
  if not f then
    local source = xpinyin.database.source
    local zfilename = source:match("[^/]+$")
    local zfile = zip.open(zfilename)
    if not zfile then
      xpinyin.download(source, zfilename)
      zfile = assert(zip.open(zfilename))
    end
    f = assert(zfile:open(xpinyin.database.file))
    zfile:close()
  end
  local s, prop
  for line in f:lines() do
    s = line:explode("\t")
    if #s == 3 then
      prop = s[2]:sub(2)
      if prop == "Mandarin" or
         prop == "HanyuPinyin" or
         prop == "XHC1983" or
         prop == "HanyuPinlu" then
        xpinyin.insert(s[1], prop, s[3])
      end
    elseif line:find("Date") then
      xpinyin.database.date = line:match("^[#%s]*(.*)")
    elseif line:find("Unicode version:") then
      xpinyin.database.version = line:match("^[#%s]*(.*)")
    end
  end
  f:close()
  if xpinyin.fixreadings then
    for _, s in pairs(xpinyin.fixreadings) do
      xpinyin.insert(s[1], s[2], s[3])
    end
  end
end
function xpinyin.download (source, zip)
  print("\nRetrieving Unihan Database from\n", source)
  local unihan_data = assert(socket.http.request(source), "download failed")
  local f = assert(io.open(zip, "wb"), "Unihan file (" .. zip .. ") not writable")
  f:write(unihan_data)
  f:close()
end
function xpinyin.insert (unicode, prop, value)
  local index = tonumber(unicode:match("%x+$"), 16)
  if not xpinyin.readings[index] then
    xpinyin.readings[index] = { }
  end
  xpinyin.readings[index][prop] = value
end
function xpinyin.output (db)
  local f = assert(io.open(db or xpinyin.database.dbfile, "w"))
  local preamble = xpinyin.preamble:gsub("%$(%w+)", xpinyin.database)
  f:write(preamble, "\n")
  local hanzi, pinyin
  local mt = { }
  for index, pyt in xpinyin.pairsByKeys(xpinyin.readings) do
    pinyin = assert(xpinyin.grep(pyt))
    hanzi = xpinyin.uchar(index)
    f:write("\\XPYU{", hanzi, "}{", index, "}{", pinyin, "}\n")
    pinyin = xpinyin.multiple(pyt)
    if pinyin then
      mt[#mt + 1] = "\\XPYUM{" .. hanzi .. "}{" .. index .. "}{" .. pinyin .."}"
    end
  end
  f:write(table.concat(mt, "\n"), "\n")
  f:close()
end
function xpinyin.pairsByKeys (t, f)
  local a = { }
  for n in pairs(t) do a[#a + 1] = n end
  table.sort(a, f)
  local i = 0 -- iterator variable
  return function () -- iterator function
    i = i + 1
    return a[i], t[a[i]]
  end
end
function xpinyin.grep (pyt)
  if pyt.Mandarin then
    return pyt.Mandarin:match("%S+"), "Mandarin"
  elseif pyt.XHC1983 then
    return pyt.XHC1983:match(":(%S+)"), "XHC1983"
  elseif pyt.HanyuPinyin then
    return pyt.HanyuPinyin:match(":([^,%s]+)"), "HanyuPinyin"
  end
end
function xpinyin.multiple (pyt)
  if pyt.XHC1983 then
    local s = pyt.XHC1983:explode()
    if s[2] then
      local t = { }
      for i, v in ipairs(s) do
        t[#t + 1] = v:explode(":")[2]
      end
      return xpinyin.unique(t), "XHC1983"
    end
  elseif pyt.HanyuPinyin and pyt.HanyuPinyin:find("%D,") then
    local t = { }
    for _, v in ipairs(pyt.HanyuPinyin:explode()) do
      for _, py in ipairs(v:explode(":")[2]:explode(",")) do
        t[#t + 1] = py
      end
    end
    return xpinyin.unique(t), "HanyuPinyin"
  end
end
function xpinyin.unique (t)
  local rt = xpinyin.remove_duplicate(t)
  if #rt > 1 then
    return table.concat(rt, ",")
  end
end
function xpinyin.remove_duplicate (t)
  local ht = { }
  local nt = { }
  for i, v in ipairs(t) do
    if not ht[v] then
      nt[#nt + 1] = v
      ht[v] = true
    end
  end
  return nt
end
xpinyin.maketable()
xpinyin.output()
--  
-- 
--  End of file `xpinyin.lua'.
